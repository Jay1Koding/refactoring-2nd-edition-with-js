# 1. 왜 리팩토링을 해야함?

1. 나쁜 코드 냄새를 맡을 수 있음 ➡️ 문제파악 가능
2. 더러운 코드를 깨끗하게 개선 ➡️ 문제해결 가능
3. 처음부터 깨끗한 코드를 작성 ➡️ 좋은 습관

---

# 2. 리팩토링 원칙

## 1. 리팩토링이 뭐임?

- 코드를 깨끗하게 만드는 작업
- 결과/행동 변경 없이 코드의 구조를 재조정
  - 소프트웨어 기능을 보존하면서 설계, 구조 및 구현을 개선
- 목표
  1. 복잡성 감소
  2. 가독성 향상
  3. 유지 보수성 개선
  4. 확장성을 높임

➡️ 더 단순하고, 깔끔하고 표현력이 뛰어난 코드, 내부 아키텍쳐/객체 모델을 만듬

- 금지

1.  기능 변경/추가
2.  버그 수정 // 리팩토링 도중에 일어나도 수정하면 안됨
3.  성능 개선
4.  버전 업데이트

### 리팩토링 그래서 뭔데?

- 리팩토링[명사] : 소프트웨어의 겉보기 동작은 그대로 유지한 채,
  코드를 이해하고 수정하기 쉽도록 **내부 구조를 변경하는 기법**
- 리팩토링한다[동사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채,
  여러가지 **리팩토링 기법을 적용**해서 소프트웨어를 재구성하다

## 2. 리팩토링이 왜 필요함?

- 왜 코드를 개선해야함?

  - 개발 초기 단계부터 완벽한 코드/시스템 설계의 어려움
  - 프로그램의 요구사항은 꾸준히 변경됨 (기능 추가/변경)
  - 더럽고 복잡한 코드는 이해하기 어려움
  - 예상하지 못한 에러가 발생하기 쉬움
  - 복잡한 코드의 유지보수는 어려움 (수정 시간이 오래걸림)

- 리팩토링 / 코드를 개선하는 이유
  - 소프트웨어 설계가 좋아짐
    - 모든 코드가 언제나 고유한 일을 수행함을 보장함
    - 이해해야할 코드의 양이 작고, 실수 없이 수정할 수 있음
- 소프트웨어를 이해하기 쉬워짐
  - 코드의 목적이 잘 드러나게, 의도를 더 명확하게 표현
  - 코드가 잘 읽힘, 가독성이 좋아짐
- 버그를 쉽게 찾을 수 있음
  - 코드가 하는 일을 깊이 파악할 수 있음
- 프로그래밍 속도를 높일 수 있음
  - 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점을 빠르게 찾음
  - 작은 일부의 코드만 이해하여 빠르게 수정 가능
  - 디버깅이 쉬움
  - 새로운 기능을 손쉽게 추가

## 3. 리팩토링 어떻게 해야함?

1. 기존에 코드에서 동작하고 있는 기능/동작을 유지하고 보장하기 위해 테스트 코드를 가지고 있어야함
   - 함수, 특정한 기능, UI, 성능, API 스펙
2. 코드의 shit smell에 따라 여러 리팩토링 기법을 점진적으로 적용해 나감
3. 단 버그는 그대로 두고 진행한다

## 4. 언제 리팩토링함?

- 수시로

- 프로젝트 시작단계

  - 기능 구현을 위한 코드를 작성
    - 좋은 디자인 패턴으로 코드를 깔끔하게 작성
  - 테스트 코드를 작성 ➡️ 작성하기 위해 하다보면 리팩토링이 됨
  - 3의 법칙 : 비슷한 일을 세 번째 하게 되면 리팩토링을 한다
  - 코드리뷰 : 코드를 이해하기 쉽게 만들기 ➡️ 좋은 문서화
  - 기능추가 : 기능을 쉽게 추가하게 만들기 ➡️ 재사용성, 모듈성

- 프로젝트 유지보수 단계

  1. 버그 수정 : 버그를 검증할 수 있는 테스트 코드

  - 코드를 이해하기 쉽게, 변경하기 쉽게 변경 / 리팩토링

  2. 기존의 기능들에 대한 테스트 확인 : 기능추가/ 디펜던시 마이그레이션

  - 코드를 이해하기 쉽게, 변경하기 쉽게 변경 / 리팩토링
  - 기능 추가

- 오래된 프로젝트
  1. 버그 수정 및 기능 추가 시에만
     - 수정이 필요한 모듈/코드 한정적으로 테스트 추가 / 리팩토링
     - 간혹 한 곳을 수정하면 여기저기 터짐
       - 코드 전체를 수정하기 힘들다면 다른 데코레이터 패턴, 어댑터 패턴, 디자인 패턴을 이용해 기존의 코드를 수정하지 않고 재사용하면서 기능을 추가
     - 코드 수정 또는 기능 추가
     - 때론 새로운 코드를 작성하는 것이 빠름

## 5. 리팩토링 중요 포인트가 뭐임

- **코드를 깨끗하게 만드는 작업**
  - 결과/행동 변경 없이 코드의 구조를 재조정
- **소프트웨어 기능을 보존하면서 설계, 구조 및 구현을 개선**
- 소프트웨어 기능 보존 확신을 위한 테스트 코드 작성
- 무결점 클린코드, 완벽한 설계는 존재하지 않는다를 인정하라

  - 좋은 디자인 패턴으로 코드를 깔끔하게 작성 (기능 구현을 위한 코드를 작성)
  - 테스트 코드를 작성
  - 추후 리팩토링
  - 3의 법칙 : 비슷한 일 세 번째 하게 되면 리팩토링 한다

- YAGNI(You Ain't Gonna Need It) 야그니
  - 깨끗하게, 변경이 쉽게, 유지보수 용이도 중요하지만
  - 필요하지 않는 기능은 ❌
  - 사용하지 않는 기능은 ❌
  - 지나치게 미래지향적 ❌

---

# 3. 코드에서 나는 악취

## 1. 코드에서 나쁜 냄새가 뭐여

- 켄트 벡 할머니의 육아 법칙 : 냄새 나면 당장 갈아라
  - 코드에서 냄새나면 리팩토링해라

> 똥은 많을 수록 최악임

## 2. 나쁜 냄새 (기본적인 악취)

- 기이한 이름(Mysterious Name) 💩💩: 코드 이해력, 가독성 ❌
- 중복 코드(Duplicated Code) 💩: 실수와 에러 발생 확률 ⬆️
- 긴 함수(Long Function) 💩: 이해하기 어려움, 재사용성 ⬇️
- 긴 매개변수 목록(Long Parameter List) 💩: 사용하기 어려움, 잦은 실수
- 전역 데이터(Global Data) 💩💩: 최악, 유령같은 버그 출몰
- 가변 데이터(Mutable Data) 💩: 예상하지 못한 곳에서 데이터를 변경

## 3. 나쁜 냄새2 (고급레벨) / 모듈성

- 뒤엉킨 변경(Divergent Change) 💩: 다양한 이유로 수정을 해야함
- 산탄총 수술(Shotgun Surgery) 💩: 여러곳에서 수정해야함
- 기능 편애(Feature Envy) 💩: 다른 모듈과 더 밀접하게 상호작용
- 데이터 뭉치(Data Clumps) 💩: 여러곳에서 항상 함께 쓰임
- 기본형 집착(Primitive Obsession) 💩: 관련된 코드가 여기저기
- 반복되는 스위치문(Repeated Switches) 💩: 새로운 타입이 추가되면 여기저기 업데이트

## 4. 나쁜 냄새3 (기타 냄새들)

- 반복문(Loops) 💩: 절차형의 코드 ➡️ 사이드 이펙 // 함수형 프로그래밍 식의 반복 파이프라인 사용함
- 성의 없는 요소(Lazy Element) 💩: 불필요한 함수, 클래스, 인터페이스
- 추측성 일반화(Speculative Generality) 💩: 혹시 모르니, 미래를 위해서
- 임시 필드(Temporary Field) 💩: 특정한 상황에서만 사용됨. 이해도 ⬇️
- 메시지 체인(Message Chains) 💩: 내부 로직이 노출됨
- 중개자(Middle Man) : 단순 전달만 하는 불필요한 코드

- 내부자 거래(Insider Trading) 💩: 모듈 내부에서 특정한 함수가 외부의 모듈을 너무 참조하거나 호출하거나 의존한다면 ?
  모듈 사이 데이터 거래 ➡️ 결합도 ⬆️
- 거대한 클래스(Large Class) 💩: 중복 코드 ⬆️, 뒤엉킨 변경 ⬆️
- 서로 다른 인터페이스의 대안 클래스들(Alternative Classes with Different Interfaces) : 서로 대체 ⬇️, 재사용성 ⬇️
- 데이터 클래스(Data Class) 💩: 필요한 로직이 여기저기
- 상속 포기(Refused Bequest) 💩: 상속의 오용, 남용은 위험
- 주석(Comments) 💩: 필요없는 주석은 악!
